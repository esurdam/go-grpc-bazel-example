# go-grpc-bazel-example

[![test](https://github.com/AdGreetz/go-grpc-bazel-example/actions/workflows/go.yml/badge.svg)](https://github.com/AdGreetz/go-grpc-bazel-example/actions/workflows/go.yml)

This repo is an example monorepo which utilizes grpc+bazel.

If proto implementation will be shared across services, implementation should reside in `pkg/`. Otherwise,
implementation can be included in `services/{{.packageName}}/pkg/`.

In this case, `helloworld` will be implemented in `pkg`.

- [Create new service](#create-a-new-service)
- [Swagger + JSON Gateway](#swagger--json-gateway)
- [Development](#development)
- [Generating BUILD.bazel files](#generating-build-files)
- [Generating proto files](#generating-proto-files)
- [Test locally](#testing)
- [Running locally](#running-service-locally)
- [Deployment](#deployment)
- [Useful Links/Resources](#useful-links)

## Layout

```
.github/     # github Action CI configs
ci/          # contains ci/automation scripts
cmd/         # command line tool entrypoints
pb/          # contains all proto definitions and gen output
pkg/         # contains proto implementations
services/    # entrypoints for kubernetes defined microservices
tools/       # tool versioning
BUILD        # root bazel BUILD definitions; aggregates services
WORKSPACE    # bazel workspace rules; external code 
```

## Requirements

`Go` and `Bazel` are the only two requirements.

This example uses bazel version 5.4.0.
[Install Bazel](https://docs.bazel.build/versions/master/install.html)

## Create a new service

Create proto file and define types/service.

```bash
touch pb/helloworld/helloworld.proto # Add definitions to this file
```

Generate `BUILD.bazel` files which contain proto and library definitions, then run `make link` to add the generated
files locally.

```bash
make gazelle
make link
```

Implement proto service in `pkg`

```bash
mkdir -p pkg/helloworld/server
touch pkg/helloworld/server/server.go
```

Create service entrypoint in `services`

```bash
mkdir services/helloworld
touch services/helloworld/main.go
```

Define kubernetes service in `ci/services`

```bash
touch ci/services/helloworld.yaml
```

Lastly, add the service definition to aggregate rule in `BUILD`.

Below represents a service scaffold.
```
project   
│
└───ci
│   └───services
│       │   helloworld.yaml
│
└───pb
│   └───helloworld
│       │   helloworld.proto
│   
└───pkg
│   └───helloworld
│       └───server
│           │   server.go
|
└───services
│   └───helloworld
│       │   main.go
|
```

## Swagger + JSON Gateway

Services may utilize `grpc-gateway` for a JSON-to-GRPC proxy. This is autogenerated with the `gateway_grpc_library` rule.
Swagger json is autogenerated via the `gateway_openapiv2_compile` rule.

```
load("@rules_proto_grpc//grpc-gateway:defs.bzl", "gateway_grpc_compile", "gateway_grpc_library", "gateway_openapiv2_compile")

gateway_grpc_library(
    name = "helloworld_gateway_lib_proto",
    importpath = "github.com/AdGreetz/go-grpc-bazel-example/pb/helloworld",
    protos = [":helloworld_proto"],
    visibility = ["//visibility:public"],
)

gateway_openapiv2_compile(
    name = "helloworld_gateway_grpc",
    protos = [":helloworld_proto"],
    visibility = ["//visibility:public"],
)
```

Services can then use the `embed` rule to embed the `swagger.json` compiled output.

View the `genrule` in [BUILD.bazel](services/helloworld/BUILD.bazel)

```
//go:embed helloworld_openapi_swagger.json
var Data []byte
```

Services can then expose the `swagger.json` file directly.

# Development

Run make link to generate proto files locally for development access.

```bash
make link
```

## Generating BUILD files

Run `make gazelle` to generate/update BUILD files (which include test and binaries).

This also updates the WORKSPACE with required deps.

BUILD.bazel files located in pb directory will contain grpc rules.

## Generating proto files

Generated files don't necessarily need to be checked in to repo. In this example, generated files are checked in. They are only necessary for local development. Otherwise, Bazel will handle generating the pb file during build.

It is generally a good idea to track changes to pb in repo.

```bash
make link
```

## Testing

To run all tests:

```bash
make test
```

Test individual package:

```bash
bazel test --features race \
  --verbose_failures \
  --test_output=errors \
  --action_env=CI=true \
  //pkg/helloworld/server:server_test
```

Tests can also be aggregated into test groups to be tested at once.

## Running service locally

Generate a self-signed certificate (cert.pem & key.pem) to run services locally. Required for multiplexing grpc/http2 over single port. 

### TLS

You can add any other hostnames as necessary.

```bash
mkdir -p ssl && \
  (cd ssl && \
    go run $GOROOT/src/crypto/tls/generate_cert.go --rsa-bits 2048 --host 127.0.0.1,::1,localhost,localhost:443,localhost:4443 --ca --start-date "Jan 1 00:00:00 1970" --duration=1000000h)
```

### Running

Use bazel to run the service
```bash
bazel run //services/helloworld:helloworld -- -http-port 4443 -cert $(pwd)/ssl/cert.pem -key $(pwd)/ssl/key.pem
```

Then we use cURL to send HTTP requests

```bash
curl -X POST -k https://localhost:4443/v1/greeter -d '{"name": "TestName"}
```
```json
{
  "message": "Hello TestName!"
}
```

You can view the swagger at [https://localhost:4443/swagger.json](https://localhost:4443/swagger.json)

### Client

With the server running, you can test command line tools from `cmd`. 
```bash
$ bazel run //cmd/helloworld-client -- \
    --name "Beutiful" \
    --server-addr localhost:4443 \
    --ca-cert $(pwd)/ssl/cert.pem

INFO: Analyzed target //cmd/helloworld-client:helloworld-client (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //cmd/helloworld-client:helloworld-client up-to-date:
  bazel-bin/cmd/helloworld-client/helloworld-client_/helloworld-client
INFO: Elapsed time: 0.365s, Critical Path: 0.00s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
INFO: Running command line: bazel-bin/cmd/helloworld-client/helloworld-client_/helloworld-client --name 'Beutiful' --server-addr localhost:4443 --cert ...
INFO: Build completed successfully, 1 total action

2022/10/22 18:03:59 message:"Hello Beutiful!"
```

### Running with Docker locally

```
oci_load(
    name = "load",
    # Use the image built for the target platform
    image = ":transitioned_image",
    repo_tags = ["ghcr.io/adgreetz/go-grpc-bazel-example/cmd/helloworld-client:latest"],
)
```

For example, to build the tarball in amd64:
```bash
bazel run \
  --platforms=@rules_go//go/toolchain:linux_amd64 \
  --cpu=k8 \
  //services/helloworld:load
# Load the tarball into docker
docker run --rm -v $(pwd)/ssl:/ssl -p 4443:4443 ghcr.io/adgreetz/go-grpc-bazel-example/services/helloworld:latest --http-port 4443 --cert /ssl/cert.pem --key /ssl/key.pem
```

arm example:
```bash
 bazel run --platforms=@rules_go//go/toolchain:linux_arm64 //services/helloworld:load
```

exclude for current platform:
```bash
bazel run //services/helloworld:load
```

# Deployment

CI checks for formatting; ensure formatting with `make fmt`

```bash
make fmt
```

## Pushing service to container registry

Used to deploy a service to the container registry.

Each service should contain a `oci_push` rule, which defines the container registry and stamped image.

```
oci_push(
    name = "push",
    image = ":transitioned_image",
    remote_tags = ":stamped",
    repository = "ghcr.io/adgreetz/go-grpc-bazel-example/cmd/helloworld-client",
    visibility = ["//visibility:public"],
)
```

To push an individual service (where version is the container label):

Iterates through all `:push` targets and pushes to the container registry.
```bash
make push
```

e.g.
```bash
bazel run --platforms=@rules_go//go/toolchain:linux_amd64 \
  --cpu=k8 \
  //services/helloworld:push
```

See [ci/push-service.sh](ci/push-service.sh)

## Kubernetes

Since [rules_docker](https://github.com/bazelbuild/rules_docker?) has been deprecated, we can no longer use the `k8s_deploy` rule to deploy to k8s. Instead, we can use the `oci_push` rule to push the image to the container registry, and then use `kubectl` to apply the deployment.

Iterates through all `:push` targets, uses the stamp to update the image tag and applies the k8s deployment.
```bash
make deploy
```

See [ci/deploy.sh](ci/deploy.sh)

# Useful Links

GRPC

- [grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway)

Bazelbuild rules

- [rules_oci](https://github.com/bazel-contrib/rules_oci/tree/main)
- [rules_docker](https://github.com/bazelbuild/rules_docker)
- [rules_go](https://github.com/bazelbuild/rules_go)
- [rules_k8s](https://github.com/bazelbuild/rules_k8s)
- [rules_proto](https://github.com/bazelbuild/rules_proto)